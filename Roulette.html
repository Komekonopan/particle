<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>被らないルーレットゲーム</title>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f3f4f6;
            color: #333;
            margin: 0;
        }
        h1 {
            color: #111;
        }
        #rouletteCanvas {
            background-color: #fff;
            border-radius: 50%;
            border: 5px solid #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .controls {
            margin: 20px 0;
        }
        button {
            font-size: 18px;
            padding: 12px 24px;
            margin: 0 10px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.1s;
        }
        button:hover:not(:disabled) {
            background-color: #0056b3;
        }
        button:active:not(:disabled) {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #resultArea {
            margin-top: 15px;
            font-size: 1.1em;
            line-height: 1.6;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            width: 460px; /* Canvasの幅と合わせる */
            min-height: 100px;
            text-align: left;
        }
        #resultArea p {
            margin: 8px 0;
        }
    </style>
</head>
<body>

    <h1>被らないルーレットゲーム</h1>

    <canvas id="rouletteCanvas" width="500" height="500"></canvas>
    
    <div class="controls">
        <button id="setupButton">ゲーム準備 (結果シャッフル)</button>
        <button id="spinButton" disabled>抽選スタート</button>
    </div>

    <div id="resultArea">
        <p>「ゲーム準備」ボタンを押して、被らない組み合わせを作成してください。</p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- ⚙️ 設定 (ここを編集してください) ---
            const participants = ["参加者A", "参加者B", "参加者C", "参加者D", "参加者E"];
            const themes = ["お題1", "お題2", "お題3", "お題4", "お題5"];
            // ルーレットの扇形の色
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#54A0FF', '#9B59B6', '#F0932B', '#EB4D4B'];
            // ------------------------------------

            // --- DOM要素 ---
            const canvas = document.getElementById('rouletteCanvas');
            const ctx = canvas.getContext('2d');
            const setupButton = document.getElementById('setupButton');
            const spinButton = document.getElementById('spinButton');
            const resultArea = document.getElementById('resultArea');

            // --- 変数 ---
            const numParticipants = participants.length;
            if (numParticipants !== themes.length) {
                alert("参加者の数とお題の数が一致しません！設定を修正してください。");
                return;
            }

            let mapping = []; // [参加者インデックス] -> お題インデックス の組み合わせ
            let currentAngle = 0; // 現在の回転角度 (ラジアン)
            const PI2 = Math.PI * 2;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 20; // 矢印のために少し内側に

            // --- イベントリスナー ---
            setupButton.addEventListener('click', setupGame);
            spinButton.addEventListener('click', startSpinning);

            /**
             * 1. ゲームのセットアップ（被らない組み合わせの生成）
             */
            function setupGame() {
                mapping = createDerangement(numParticipants);
                if (!mapping) {
                    resultArea.innerHTML = `<p style="color: red;">エラー: 被らない組み合わせの生成に失敗しました。再試行してください。</p>`;
                    return;
                }
                
                resultArea.innerHTML = "<p>準備完了！「抽選スタート」を押してください。</p>";
                console.log("生成されたマッピング (参加者i -> お題j):", mapping);
                
                spinButton.disabled = false;
                setupButton.disabled = true; // 準備は1回だけ
            }
            
            /**
             * 2. 完全攪乱（i != array[i]）の配列を生成
             */
            function createDerangement(n) {
                let arr = Array.from({length: n}, (_, i) => i);
                let attempts = 0;
                
                while (attempts < 1000) { // 試行回数を増やす
                    // Fisher-Yates シャッフル
                    for (let i = arr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                    }
                    
                    // 被りがないかチェック
                    let isDerangement = true;
                    for (let i = 0; i < n; i++) {
                        if (arr[i] === i) {
                            isDerangement = false;
                            break;
                        }
                    }
                    
                    if (isDerangement) {
                        return arr; // 成功
                    }
                    attempts++;
                }
                
                console.warn("完全攪乱の生成に失敗しました。");
                return null; // 失敗
            }

            /**
             * 3. ルーレット盤面を描画
             */
            function drawRoulette(angle) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const arcSize = PI2 / numParticipants; // 1区画の角度

                for (let i = 0; i < numParticipants; i++) {
                    ctx.beginPath();
                    const startAngle = angle + i * arcSize;
                    const endAngle = startAngle + arcSize;
                    
                    // 扇形を描画
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                    ctx.closePath();
                    
                    ctx.fillStyle = colors[i % colors.length];
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // テキスト（お題）を描画
                    ctx.save();
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 16px sans-serif';
                    ctx.translate(centerX, centerY);
                    
                    // テキストの角度を扇形の中央に
                    const textAngle = startAngle + arcSize / 2;
                    ctx.rotate(textAngle);
                    
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    // 円の外側を向くようにテキストを配置
                    ctx.fillText(themes[i], radius * 0.7, 0);
                    ctx.restore();
                }
            }

            /**
             * 4. 矢印を描画 (常に固定)
             */
            function drawArrow() {
                ctx.fillStyle = '#E74C3C'; // 目立つ赤色
                ctx.beginPath();
                // 矢印の先端をルーレット盤の真上に
                ctx.moveTo(centerX, centerY - radius - 15);
                ctx.lineTo(centerX - 10, centerY - radius - 5);
                ctx.lineTo(centerX + 10, centerY - radius - 5);
                ctx.closePath();
                ctx.fill();
                
                // 軸
                ctx.beginPath();
                ctx.arc(centerX, centerY, 10, 0, PI2);
                ctx.fillStyle = '#555';
                ctx.fill();
            }

            /**
             * 5. 抽選スタート（一人ずつアニメーション）
             */
            async function startSpinning() {
                spinButton.disabled = true;
                resultArea.innerHTML = ""; // 結果表示エリアをリセット
                
                for (let i = 0; i < numParticipants; i++) {
                    // 参加者iが当たるべきお題のインデックス
                    const targetThemeIndex = mapping[i]; 
                    
                    resultArea.innerHTML += `<p><strong>${participants[i]}</strong> の番です... </p>`;
                    
                    // アニメーション実行
                    await animateSpin(targetThemeIndex);
                    
                    // 結果を確定して表示
                    const resultP = resultArea.querySelector('p:last-child');
                    resultP.innerHTML = `<strong>${participants[i]}</strong> は <strong>${themes[targetThemeIndex]}</strong> に決定！`;
                    
                    await sleep(1500); // 次の人までの待機時間
                }
                
                resultArea.innerHTML += "<h3>全員の抽選が完了しました！</h3>";
                setupButton.disabled = false; // 再度準備できるようにする
            }

            /**
             * 6. 1回分のスピンアニメーション
             */
            function animateSpin(targetIndex) {
                return new Promise(resolve => {
                    const arcSize = PI2 / numParticipants;
                    
                    // 停止目標角度（矢印（真上）に、お題セクターの中央が来る角度）
                    // 真上は -PI/2 (270度)
                    let targetAngle = - (targetIndex * arcSize + arcSize / 2) + (Math.PI / 2);
                    
                    // ランダムなオフセットを追加して停止位置を微調整
                    targetAngle -= (Math.random() * 0.6 - 0.3) * arcSize; 
                    
                    // 最低でも5回転はさせる
                    const totalRotation = PI2 * (5 + Math.random() * 2);
                    const finalAngle = targetAngle + totalRotation;
                    
                    const duration = 5000; // アニメーション時間 (5秒)
                    const startTime = performance.now();
                    const startAngle = currentAngle; // 前回の停止位置からスタート

                    // イージング関数 (だんだん遅くなる)
                    function easeOutQuart(t) {
                        return 1 - (--t) * t * t * t;
                    }

                    function animate(currentTime) {
                        const elapsedTime = currentTime - startTime;
                        let t = elapsedTime / duration;
                        
                        if (t >= 1.0) t = 1.0;
                        
                        const easedT = easeOutQuart(t);
                        
                        // 現在の角度を計算
                        currentAngle = startAngle + (finalAngle - startAngle) * easedT;
                        
                        drawRoulette(currentAngle);
                        drawArrow();

                        if (t < 1.0) {
                            requestAnimationFrame(animate);
                        } else {
                            // アニメーション終了
                            currentAngle = finalAngle; // 最終角度に固定
                            resolve();
                        }
                    }
                    
                    requestAnimationFrame(animate);
                });
            }
            
            /**
             * 待機用関数
             */
            function sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            // --- 初期描画 ---
            initialDraw();
            
            function initialDraw() {
                drawRoulette(0); // 0度の状態で初期描画
                drawArrow();
            }
        });
    </script>

</body>
</html>
